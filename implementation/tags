!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FIELD_DESCRIPTION!Python	nameref	/the original name for the tag/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C	m,member	/struct, and union members/
!_TAG_KIND_DESCRIPTION!C	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Python	I,namespace	/name referring a module defined in other file/
!_TAG_KIND_DESCRIPTION!Python	Y,unknown	/name referring a class\/variable\/function\/module defined in other module/
!_TAG_KIND_DESCRIPTION!Python	c,class	/classes/
!_TAG_KIND_DESCRIPTION!Python	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Python	i,module	/modules/
!_TAG_KIND_DESCRIPTION!Python	m,member	/class members/
!_TAG_KIND_DESCRIPTION!Python	v,variable	/variables/
!_TAG_KIND_DESCRIPTION!Sh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Sh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Sh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Sh	s,script	/script files/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C	1.1	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PARSER_VERSION!Python	0.0	/current.age/
!_TAG_PARSER_VERSION!Sh	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/jppm/Documents/dsa/implementation/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	/v6.1.0/
!_TAG_ROLE_DESCRIPTION!C!function	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C!struct	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
!_TAG_ROLE_DESCRIPTION!Python!module	imported	/imported modules/
!_TAG_ROLE_DESCRIPTION!Python!module	indirectlyImported	/module imported in alternative name/
!_TAG_ROLE_DESCRIPTION!Python!module	namespace	/namespace from where classes\/variables\/functions are imported/
!_TAG_ROLE_DESCRIPTION!Python!unknown	imported	/imported from the other module/
!_TAG_ROLE_DESCRIPTION!Python!unknown	indirectlyImported	/classes\/variables\/functions\/modules imported in alternative name/
!_TAG_ROLE_DESCRIPTION!Sh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Sh!script	loaded	/loaded/
%.o	Makefile	/^%.o: %.c$/;"	t
ARRAY_MAX_SIZE	hashmap.h	/^#define ARRAY_MAX_SIZE /;"	d
Bst	dsa.h	/^typedef struct Bst Bst;$/;"	t	typeref:struct:Bst
BstNode	dsa.h	/^typedef struct BstNode BstNode;$/;"	t	typeref:struct:BstNode
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS=-Wall -Wextra  -g$/;"	m
DYNAMICARRAYCAP	dynamicArray.h	/^#define DYNAMICARRAYCAP /;"	d
DynamicArray	dynamicArray.h	/^struct DynamicArray {$/;"	s
DynamicArray	dynamicArray.h	/^typedef struct DynamicArray DynamicArray;$/;"	t	typeref:struct:DynamicArray
EXEC	Makefile	/^EXEC=dsa$/;"	m
Graph	dsa.h	/^typedef struct Graph Graph;$/;"	t	typeref:struct:Graph
HASHMAP_TYPE_NUMBER	hashmap.h	/^#define HASHMAP_TYPE_NUMBER /;"	d
HASHMAP_TYPE_STRING	hashmap.h	/^#define HASHMAP_TYPE_STRING /;"	d
HashMap	dsa.h	/^typedef struct HashMap HashMap;$/;"	t	typeref:struct:HashMap
Hashmap	hashmap.h	/^struct Hashmap {$/;"	s
Hashmap	hashmap.h	/^typedef struct Hashmap Hashmap;$/;"	t	typeref:struct:Hashmap
HashmapNode	hashmap.h	/^typedef struct HashmapNode HashmapNode;$/;"	t	typeref:struct:HashmapNode
HashmapNode	linkedList.h	/^struct HashmapNode {$/;"	s
HashmapNode	linkedList.h	/^typedef struct HashmapNode HashmapNode;$/;"	t	typeref:struct:HashmapNode
IS_NUMBER	hashmap.h	/^#define IS_NUMBER(/;"	d
LinkedList	linkedList.h	/^struct LinkedList {$/;"	s
LinkedList	linkedList.h	/^typedef struct LinkedList LinkedList;$/;"	t	typeref:struct:LinkedList
LinkedListNode	linkedList.h	/^struct LinkedListNode {$/;"	s
LinkedListNode	linkedList.h	/^typedef struct LinkedListNode LinkedListNode;$/;"	t	typeref:struct:LinkedListNode
MODULE_FACTOR	hashmap.h	/^#define MODULE_FACTOR /;"	d
OBJ	Makefile	/^OBJ=$(SRC:.c=.o)$/;"	m
Queue	dsa.h	/^typedef struct Queue Queue;$/;"	t	typeref:struct:Queue
Queue	queue.h	/^struct Queue {$/;"	s
Queue	queue.h	/^typedef struct Queue Queue;$/;"	t	typeref:struct:Queue
SRC	Makefile	/^SRC=$(wildcard *.c)$/;"	m
Stack	dsa.h	/^typedef struct Stack Stack;$/;"	t	typeref:struct:Stack
Stack	stack.h	/^struct Stack {$/;"	s
Stack	stack.h	/^typedef struct Stack Stack;$/;"	t	typeref:struct:Stack
__DSA__	dsa.h	/^#define __DSA__$/;"	d
__DYNAMIC_ARRAY__	dynamicArray.h	/^#define __DYNAMIC_ARRAY__$/;"	d
__HASH_MAP__	hashmap.h	/^#define __HASH_MAP__$/;"	d
__LINKED_LIST__	linkedList.h	/^#define __LINKED_LIST__$/;"	d
__QUEUE__	queue.h	/^#define __QUEUE__$/;"	d
__STACK__	stack.h	/^#define __STACK__$/;"	d
addElement	dynamicArray.c	/^void addElement(DynamicArray *dynamicArray, void *element) {$/;"	f	typeref:typename:void
addElement	dynamicArray.h	/^  void (*addElement)(DynamicArray *dynamicArray, void *element);$/;"	m	struct:DynamicArray	typeref:typename:void (*)(DynamicArray * dynamicArray,void * element)
addNode	linkedList.c	/^void addNode(LinkedList *linkedList, LinkedListNode *node) {$/;"	f	typeref:typename:void
addNode	linkedList.h	/^  void (*addNode)(LinkedList *linkedList, LinkedListNode *node);$/;"	m	struct:LinkedList	typeref:typename:void (*)(LinkedList * linkedList,LinkedListNode * node)
all	Makefile	/^all: $(EXEC)$/;"	t
array	dynamicArray.h	/^  void *array;$/;"	m	struct:DynamicArray	typeref:typename:void *
array	hashmap.h	/^  void *array[ARRAY_MAX_SIZE];$/;"	m	struct:Hashmap	typeref:typename:void * []
bottomIndex	dynamicArray.h	/^  int bottomIndex;$/;"	m	struct:DynamicArray	typeref:typename:int
clean	Makefile	/^clean:$/;"	t
counter	dynamicArray.h	/^  int counter;$/;"	m	struct:DynamicArray	typeref:typename:int
counter	hashmap.h	/^  int counter;$/;"	m	struct:Hashmap	typeref:typename:int
deleteNode	linkedList.c	/^LinkedListNode *deleteNode(LinkedListNode *antNode, LinkedListNode *node,$/;"	f	typeref:typename:LinkedListNode *
deleteNode	linkedList.h	/^  LinkedListNode *(*deleteNode)(LinkedListNode *antNode, LinkedListNode *node,$/;"	m	struct:LinkedList	typeref:typename:LinkedListNode * (*)(LinkedListNode * antNode,LinkedListNode * node,void * value)
dequeue	queue.c	/^void *dequeue(Queue *queue) {$/;"	f	typeref:typename:void *
dequeue	queue.h	/^  void *(*dequeue)(Queue *queue);$/;"	m	struct:Queue	typeref:typename:void * (*)(Queue * queue)
destroyDynamicArray	dynamicArray.c	/^void destroyDynamicArray(DynamicArray *dynamicArray) {$/;"	f	typeref:typename:void
destroyHashmap	hashmap.c	/^void destroyHashmap(Hashmap *hashmap) {$/;"	f	typeref:typename:void
destroyHashmapNode	linkedList.c	/^void destroyHashmapNode(HashmapNode *hashmapNode) {$/;"	f	typeref:typename:void
destroyQueue	queue.c	/^void destroyQueue(Queue *queue) {$/;"	f	typeref:typename:void
destroyStack	stack.c	/^void destroyStack(Stack *stack) {$/;"	f	typeref:typename:void
dsa	Makefile	/^dsa: $(OBJ)$/;"	t
dynamicArray	queue.h	/^  DynamicArray *dynamicArray;$/;"	m	struct:Queue	typeref:typename:DynamicArray *
dynamicArray	stack.h	/^  DynamicArray *dynamicArray;$/;"	m	struct:Stack	typeref:typename:DynamicArray *
element	linkedList.h	/^  void *element;$/;"	m	struct:LinkedListNode	typeref:typename:void *
enqueue	queue.c	/^void enqueue(Queue *queue, void *element) {$/;"	f	typeref:typename:void
enqueue	queue.h	/^  void (*enqueue)(Queue *queue, void *element);$/;"	m	struct:Queue	typeref:typename:void (*)(Queue * queue,void * element)
getElement	dynamicArray.c	/^void *getElement(DynamicArray *dynamicArray, int position) {$/;"	f	typeref:typename:void *
getElement	dynamicArray.h	/^  void *(*getElement)(DynamicArray *dynamicArray, int position);$/;"	m	struct:DynamicArray	typeref:typename:void * (*)(DynamicArray * dynamicArray,int position)
hashFunction	hashmap.c	/^int hashFunction(Hashmap *hashmap, void *key) {$/;"	f	typeref:typename:int
hashmapContainsKey	hashmap.c	/^bool hashmapContainsKey(Hashmap *hashmap, void *key) { return true; }$/;"	f	typeref:typename:bool
hashmapContainsKey	hashmap.h	/^  bool (*hashmapContainsKey)(Hashmap *hashmap, void *key);$/;"	m	struct:Hashmap	typeref:typename:bool (*)(Hashmap * hashmap,void * key)
hashmapContainsValue	hashmap.c	/^bool hashmapContainsValue(Hashmap *hashmap, void *element) { return true; }$/;"	f	typeref:typename:bool
hashmapContainsValue	hashmap.h	/^  bool (*hashmapContainsValue)(Hashmap *hashmap, void *value);$/;"	m	struct:Hashmap	typeref:typename:bool (*)(Hashmap * hashmap,void * value)
hashmapGet	hashmap.c	/^void hashmapGet(Hashmap *hashmap, void *key) {}$/;"	f	typeref:typename:void
hashmapGet	hashmap.h	/^  void (*hashmapGet)(Hashmap *hashmap, void *key);$/;"	m	struct:Hashmap	typeref:typename:void (*)(Hashmap * hashmap,void * key)
hashmapPut	hashmap.c	/^void hashmapPut(Hashmap *hashmap, void *key, void *value) {$/;"	f	typeref:typename:void
hashmapPut	hashmap.h	/^  void (*hashmapPut)(Hashmap *hashmap, void *key, void *value);$/;"	m	struct:Hashmap	typeref:typename:void (*)(Hashmap * hashmap,void * key,void * value)
hashmapRemove	hashmap.c	/^void hashmapRemove(Hashmap *hashmap, void *key) {}$/;"	f	typeref:typename:void
hashmapRemove	hashmap.h	/^  void (*hashmapRemove)(Hashmap *hashmap, void *key);$/;"	m	struct:Hashmap	typeref:typename:void (*)(Hashmap * hashmap,void * key)
head	linkedList.h	/^  LinkedListNode *head;$/;"	m	struct:LinkedList	typeref:typename:LinkedListNode *
key	linkedList.h	/^  void *key;$/;"	m	struct:HashmapNode	typeref:typename:void *
keyType	hashmap.h	/^  char *keyType;$/;"	m	struct:Hashmap	typeref:typename:char *
main	dsa.c	/^int main(void) {$/;"	f	typeref:typename:int
main	dsaTest.py	/^def main() -> None:$/;"	f	typeref:typename:None
mrproper	Makefile	/^mrproper: clean$/;"	t
newDynamicArray	dynamicArray.c	/^DynamicArray *newDynamicArray() {$/;"	f	typeref:typename:DynamicArray *
newHashmap	hashmap.c	/^Hashmap *newHashmap(char *keyType, char *valueType) {$/;"	f	typeref:typename:Hashmap *
newHashmapNode	linkedList.c	/^HashmapNode *newHashmapNode(void *key, void *value) {$/;"	f	typeref:typename:HashmapNode *
newLinkedList	linkedList.c	/^LinkedList *newLinkedList() {$/;"	f	typeref:typename:LinkedList *
newLinkedListNode	linkedList.c	/^LinkedListNode *newLinkedListNode(void *value) {$/;"	f	typeref:typename:LinkedListNode *
newQueue	queue.c	/^Queue *newQueue() {$/;"	f	typeref:typename:Queue *
newStack	stack.c	/^Stack *newStack() {$/;"	f	typeref:typename:Stack *
next	linkedList.h	/^  LinkedListNode *next;$/;"	m	struct:LinkedListNode	typeref:typename:LinkedListNode *
peek	stack.c	/^void peek(Stack *stack) {$/;"	f	typeref:typename:void
peek	stack.h	/^  void (*peek)(Stack *stack);$/;"	m	struct:Stack	typeref:typename:void (*)(Stack * stack)
pop	stack.c	/^void *pop(Stack *stack) {$/;"	f	typeref:typename:void *
pop	stack.h	/^  void* (*pop)(Stack *stack);$/;"	m	struct:Stack	typeref:typename:void * (*)(Stack * stack)
push	stack.c	/^void push(Stack *stack, void *element) {$/;"	f	typeref:typename:void
push	stack.h	/^  void (*push)(Stack *stack, void *element);$/;"	m	struct:Stack	typeref:typename:void (*)(Stack * stack,void * element)
queueIsEmpty	queue.c	/^bool queueIsEmpty(Queue *queue) {$/;"	f	typeref:typename:bool
queueIsEmpty	queue.h	/^  bool (*queueIsEmpty)(Queue *queue);$/;"	m	struct:Queue	typeref:typename:bool (*)(Queue * queue)
queueSize	queue.c	/^int queueSize(Queue *queue) { return queue->dynamicArray->size; }$/;"	f	typeref:typename:int
queueSize	queue.h	/^  int (*queueSize)();$/;"	m	struct:Queue	typeref:typename:int (*)()
removeElementBack	dynamicArray.c	/^void removeElementBack(DynamicArray *dynamicArray, int position) {$/;"	f	typeref:typename:void
removeElementBack	dynamicArray.h	/^  void (*removeElementBack)(DynamicArray *dynamicArray, int position);$/;"	m	struct:DynamicArray	typeref:typename:void (*)(DynamicArray * dynamicArray,int position)
removeElementFront	dynamicArray.c	/^void removeElementFront(DynamicArray *dynamicArray, int position) {$/;"	f	typeref:typename:void
removeElementFront	dynamicArray.h	/^  void (*removeElementFront)(DynamicArray *dynamicArray, int position);$/;"	m	struct:DynamicArray	typeref:typename:void (*)(DynamicArray * dynamicArray,int position)
setElement	dynamicArray.c	/^void setElement(DynamicArray *dynamicArray, int position, void *element) {$/;"	f	typeref:typename:void
setElement	dynamicArray.h	/^  void (*setElement)(DynamicArray *dynamicArray, int postion, void *element);$/;"	m	struct:DynamicArray	typeref:typename:void (*)(DynamicArray * dynamicArray,int postion,void * element)
showArray	dynamicArray.c	/^void showArray(DynamicArray *dynamicArray) {$/;"	f	typeref:typename:void
showArray	dynamicArray.h	/^  void (*showArray)(DynamicArray *dynamicArray);$/;"	m	struct:DynamicArray	typeref:typename:void (*)(DynamicArray * dynamicArray)
showLinkedList	linkedList.c	/^void showLinkedList(LinkedListNode *node) {$/;"	f	typeref:typename:void
showLinkedList	linkedList.h	/^  void (*showLinkedList)(LinkedListNode *node);$/;"	m	struct:LinkedList	typeref:typename:void (*)(LinkedListNode * node)
showLinkedListHashmapNode	linkedList.c	/^void showLinkedListHashmapNode(LinkedListNode *node) {$/;"	f	typeref:typename:void
showLinkedListIterative	linkedList.h	/^  void (*showLinkedListIterative)(LinkedListNode *node);$/;"	m	struct:LinkedList	typeref:typename:void (*)(LinkedListNode * node)
showLinkedListNormalNode	linkedList.c	/^void showLinkedListNormalNode(LinkedListNode *node) {$/;"	f	typeref:typename:void
size	dynamicArray.h	/^  int size;$/;"	m	struct:DynamicArray	typeref:typename:int
stackIsEmpty	stack.c	/^bool stackIsEmpty(Stack *stack) {$/;"	f	typeref:typename:bool
stackIsEmpty	stack.h	/^  bool (*stackIsEmpty)(Stack *stack);$/;"	m	struct:Stack	typeref:typename:bool (*)(Stack * stack)
testHashmap	dsaTest.py	/^def testHashmap() -> None:$/;"	f	typeref:typename:None
value	linkedList.h	/^  void *value;$/;"	m	struct:HashmapNode	typeref:typename:void *
valueType	hashmap.h	/^  char *valueType;$/;"	m	struct:Hashmap	typeref:typename:char *
